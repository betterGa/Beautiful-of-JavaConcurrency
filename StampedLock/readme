JDK 1.8 StampedLock
   该锁提供了三种模式的读写控制，
   当调用获取锁的方法时，会返回一个 long 类型的变量，称之为 戳记 stamp，
   这个戳记代表了锁的状态。try 系列获取锁的方法，
   当获取锁失败后 会返回为 0 的 stamp 值。
   当调用释放锁 和 转换锁的方法时 需要传入 获取锁时返回的 stamp 值。

三种读写模式的锁：
🔒写锁 writeLock
    独占锁。某时只有一个线程可以获取该锁，当一个线程获取该锁后，其他请求 读锁 和 写锁的线程必须等待。也就是说，当前没有线程持有读锁 或者 写锁时，才可以获取到该锁。请求该锁成功后 会返回一个 stamp 变量用来表示该锁的版本。当释放该锁时，需要调用 unlockWrite 方法 并传递读取锁时的 stamp 参数。并且它提供了非阻塞的 tryWriteLock 方法。

🔒悲观读锁 readLock：
    共享锁。在没有线程获取独占写锁的情况下，多个线程可以同时获取该锁。如果已有线程持有写锁，则 其他线程请求获取该读锁会被阻塞（类似于 ReentranReadWriteLock 的读锁，不同的是 这里读锁是不可重入锁）。 这里的悲观是说，在具体操作数据前，它会悲观地认为 其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在 读少写多 的情况下的一种考虑。请求该锁成功会返回一个 stamp 参数，表示该锁的版本，当释放该锁时，需要调用 unlockRead 方法并传递 stamp 参数。并且它提供了非阻塞的 tryWriteLock 方法。

🔒乐观读锁 tryOptimisticRead：
    相对于悲观锁， 数据操作前没有通过 CAS 设置锁的状态，（那么也就不需要显式地释放锁，而且适合于 读多写少 的场景）仅通过位运算测试。如果当前没有线程持有写锁，则 简单地返回一个 非 0 的 stamp 版本信息。获取该 stamp 后 在具体操作数据前，还需要调用 validate 方法验证该 stamp 是否已经不可用。由于没有使用到真的锁，在保证数据一致性上 需要复制一份要操作的变量到方法栈，并且在操作数据时 可能其他写线程已经修改了数据，而 我们操作的是方法栈里的数据，也就是一个快照📸 ，可能返回的不是最新的数据。

    StampedLock 还支持这三种锁在一定条件下进行互相转换，
    比如 LongConvertToWriteLock(long stamp) 期望把 stamp 标示的锁 升级为写锁，
    满足以下三个条件，就可以晋升写锁成功，并返回有效的 stamp ：
（1）当前锁已经是写锁模式了。
（2）当前锁处于读锁模式，并且没有其他线程是读锁模式。
（3）当前处于乐观读模式，并且当前写锁可用。

    StampedLock 的读写锁都是不可重入锁 ，、
    所以 在获取锁后 释放锁前 不应该再调用会获取锁的操作，
    以避免造成调用线程被阻塞。
    当多个线程同时尝试获取读锁 和 写锁 时，哪个线程先获取到锁是随机的。
    并且 锁不是直接实现实现 Lock 或 ReadWriteLock 接口，
    而是其在内部自己维护一个双向阻塞的 队列。