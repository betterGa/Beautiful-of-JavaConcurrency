 死锁 是指 两个 或 两个以上的线程在执行过程中，因为争夺资源 而造成的 互相等待的现象。
 在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去：

✨ 死锁的产生必须具备以下四个条件：
(1)互斥条件
    线程对已经获取到的资源进行排他性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
(2)请求并持有条件
    一个线程已经持有了至少一个资源，但又提出了新的资源请求，而 新资源已被其他线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。
(3)不可剥夺条件
    线程获取到的资源 在自己使用完之前 不能被其他线程抢占，只有在自己使用完毕后 才由自己释放该资源。
(4)环路等待条件
指在发生死锁时，必然存在一个线程 — 资源的环形链，即线程集合{T0,T1,T2,… …,Tn} 中的 T0 正在等待 T1 占用的资源，T1 正在等待 T2 占用的资源 … … Tn 正在等待已被 T0 占用的资源。


如何避免线程死锁
    要想避免死锁，只需要破坏掉至少一个构造死锁的必要条件即可。
    目前只有 请求并持有 和 环路等待 条件是可以被破坏的。
    造成死锁的原因其实和 申请资源的顺序 有很大关系，
    使用资源申请的有序性原则 就可以避免死锁，
    资源的有序性会破坏资源的请求并持有条件 和 环路等待 条件。